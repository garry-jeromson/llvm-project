//===-- W65816ISelDAGToDAG.cpp - A DAG to DAG Inst Selector for W65816 ----===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file defines an instruction selector for the W65816 target.
//
//===----------------------------------------------------------------------===//

#include "W65816.h"
#include "W65816ISelLowering.h"
#include "W65816Subtarget.h"
#include "W65816TargetMachine.h"
#include "MCTargetDesc/W65816MCTargetDesc.h"

#include "llvm/CodeGen/MachineFrameInfo.h"
#include "llvm/CodeGen/MachineFunction.h"
#include "llvm/CodeGen/MachineRegisterInfo.h"
#include "llvm/CodeGen/SelectionDAG.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/CodeGen/SelectionDAGNodes.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/GlobalVariable.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/raw_ostream.h"

#define DEBUG_TYPE "w65816-isel"
#define PASS_NAME "W65816 DAG->DAG Instruction Selection"

using namespace llvm;

namespace {

/// Check if a global variable is in the zero/direct page section.
/// The W65816 direct page allows 8-bit addressing for the first 256 bytes.
/// Globals marked with section ".zeropage" or ".directpage" can use
/// the faster 2-byte direct page instructions.
static bool isDirectPageGlobal(const GlobalValue *GV) {
  if (!GV)
    return false;

  StringRef Section = GV->getSection();
  if (Section.empty())
    return false;

  // Check for common zero page section names
  return Section == ".zeropage" || Section == ".directpage" ||
         Section == ".zp" || Section == "zeropage" || Section == "directpage";
}

/// Check if a global variable requires long (24-bit) addressing.
/// Globals in sections like ".fardata", ".rodata", or ".romdata" are assumed
/// to be in a different bank and require 4-byte long addressing instructions.
/// This is common for SNES development where ROM data is in banks $00-$7F.
static bool isFarGlobal(const GlobalValue *GV) {
  if (!GV)
    return false;

  StringRef Section = GV->getSection();
  if (Section.empty())
    return false;

  // Check for common far/ROM section names
  return Section == ".fardata" || Section == ".far" ||
         Section == ".romdata" || Section == ".rodata" ||
         Section.starts_with(".bank");
}

class W65816DAGToDAGISel : public SelectionDAGISel {
public:
  W65816DAGToDAGISel() = delete;

  explicit W65816DAGToDAGISel(W65816TargetMachine &TM, CodeGenOptLevel OptLevel)
      : SelectionDAGISel(TM, OptLevel) {}

  bool runOnMachineFunction(MachineFunction &MF) override {
    Subtarget = &MF.getSubtarget<W65816Subtarget>();
    return SelectionDAGISel::runOnMachineFunction(MF);
  }

  void Select(SDNode *N) override;

  bool SelectAddr(SDValue Addr, SDValue &Base);

  StringRef getPassName() const { return PASS_NAME; }

// Include the pieces autogenerated from the target description
#include "W65816GenDAGISel.inc"

private:
  const W65816Subtarget *Subtarget = nullptr;
};

class W65816DAGToDAGISelLegacy : public SelectionDAGISelLegacy {
public:
  static char ID;

  explicit W65816DAGToDAGISelLegacy(W65816TargetMachine &TM,
                                    CodeGenOptLevel OptLevel)
      : SelectionDAGISelLegacy(
            ID, std::make_unique<W65816DAGToDAGISel>(TM, OptLevel)) {}
};

char W65816DAGToDAGISelLegacy::ID = 0;

} // end anonymous namespace

INITIALIZE_PASS(W65816DAGToDAGISelLegacy, DEBUG_TYPE, PASS_NAME, false, false)

void W65816DAGToDAGISel::Select(SDNode *N) {
  // If we have a custom node, we have already selected
  if (N->isMachineOpcode()) {
    LLVM_DEBUG(dbgs() << "== "; N->dump(CurDAG); dbgs() << "\n");
    N->setNodeId(-1);
    return;
  }

  unsigned Opcode = N->getOpcode();
  SDLoc DL(N);

  switch (Opcode) {
  default:
    break;

  // Note: CopyToReg is handled by default selection. The MOV16ri pattern
  // will be selected for immediate loads, then COPY instructions will copy
  // to physical registers. This ensures proper liveness for call argument
  // setup. The MOV16ri pseudo is later expanded to LDA/LDX/LDY_imm16.

  case ISD::FrameIndex: {
    // When FrameIndex is used as a value (e.g., passed to a call as a pointer),
    // we need to materialize the stack address into a register.
    // Use LEA (Load Effective Address) pseudo to compute the address.
    int FI = cast<FrameIndexSDNode>(N)->getIndex();
    SDValue TFI = CurDAG->getTargetFrameIndex(FI, MVT::i16);
    // Create an ADDri to compute SP + offset. This will be lowered to proper
    // stack address computation after frame lowering.
    // For now, use a MOV16ri with the frame index which will be handled
    // during frame lowering to become the actual address computation.
    MachineSDNode *LEA = CurDAG->getMachineNode(
        W65816::LEA_fi, DL, MVT::i16, TFI);
    ReplaceNode(N, LEA);
    return;
  }

  case W65816ISD::WRAPPER: {
    // WRAPPER just contains the target address - select it as-is
    // The inner TargetGlobalAddress will be used directly
    SDValue Addr = N->getOperand(0);
    // For WRAPPER nodes used as addresses, we let the pattern matching
    // handle them via SelectAddr. If WRAPPER is used standalone,
    // we need to materialize the address.
    // For now, just replace with the inner address
    ReplaceNode(N, Addr.getNode());
    return;
  }

  case ISD::STORE: {
    // Check if storing to a frame index - use stack-relative addressing
    StoreSDNode *ST = cast<StoreSDNode>(N);
    SDValue Chain = ST->getChain();
    SDValue Value = ST->getValue();
    SDValue Addr = ST->getBasePtr();

    // Only handle simple stores of i16
    if (ST->getMemoryVT() == MVT::i16 && !ST->isTruncatingStore()) {
      // Check for store of constant zero - use STZ instruction
      if (ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Value)) {
        if (CN->isZero()) {
          // Store zero to absolute address
          if (Addr.getOpcode() == W65816ISD::WRAPPER) {
            SDValue Inner = Addr.getOperand(0);
            if (GlobalAddressSDNode *GA = dyn_cast<GlobalAddressSDNode>(Inner)) {
              if (isDirectPageGlobal(GA->getGlobal())) {
                // Use direct page STZ (2-byte instruction)
                SDValue TargetAddr = CurDAG->getTargetGlobalAddress(
                    GA->getGlobal(), DL, MVT::i8, GA->getOffset());
                SDValue Ops[] = {TargetAddr, Chain};
                MachineSDNode *Store =
                    CurDAG->getMachineNode(W65816::STZ_dp, DL, MVT::Other, Ops);
                CurDAG->setNodeMemRefs(Store, {ST->getMemOperand()});
                ReplaceNode(N, Store);
                return;
              }
              // Use absolute STZ (3-byte instruction)
              SDValue TargetAddr = CurDAG->getTargetGlobalAddress(
                  GA->getGlobal(), DL, MVT::i16, GA->getOffset());
              SDValue Ops[] = {TargetAddr, Chain};
              MachineSDNode *Store =
                  CurDAG->getMachineNode(W65816::STZ_abs, DL, MVT::Other, Ops);
              CurDAG->setNodeMemRefs(Store, {ST->getMemOperand()});
              ReplaceNode(N, Store);
              return;
            }
          }
        }
      }

      // Memory operation optimization: detect load-modify-store patterns
      // and replace with single memory instructions (INC/DEC/ASL/LSR)
      // Pattern: store(op(load(addr)), addr) where op is add/sub/shl/lshr by 1
      if (Addr.getOpcode() == W65816ISD::WRAPPER) {
        SDValue Inner = Addr.getOperand(0);
        if (GlobalAddressSDNode *GA = dyn_cast<GlobalAddressSDNode>(Inner)) {
          // Check what operation is being stored
          unsigned MemOpc = 0;
          SDValue LoadVal;

          // Check for add/sub by 1 (INC/DEC)
          // Note: sub x, 1 is canonicalized to add x, -1
          if (Value.getOpcode() == ISD::ADD || Value.getOpcode() == ISD::SUB) {
            SDValue LHS = Value.getOperand(0);
            SDValue RHS = Value.getOperand(1);

            // Check for (add/sub load, const) or (add const, load)
            if (ConstantSDNode *CN = dyn_cast<ConstantSDNode>(RHS)) {
              if (LHS.getOpcode() == ISD::LOAD) {
                int64_t Val = CN->getSExtValue();
                if (Val == 1) {
                  LoadVal = LHS;
                  MemOpc = (Value.getOpcode() == ISD::ADD) ? W65816::INC_abs : W65816::DEC_abs;
                } else if (Val == -1 && Value.getOpcode() == ISD::ADD) {
                  // add x, -1 is the same as sub x, 1 (DEC)
                  LoadVal = LHS;
                  MemOpc = W65816::DEC_abs;
                }
              }
            } else if (Value.getOpcode() == ISD::ADD) {
              if (ConstantSDNode *CN = dyn_cast<ConstantSDNode>(LHS)) {
                if (RHS.getOpcode() == ISD::LOAD) {
                  int64_t Val = CN->getSExtValue();
                  if (Val == 1) {
                    LoadVal = RHS;
                    MemOpc = W65816::INC_abs;
                  } else if (Val == -1) {
                    LoadVal = RHS;
                    MemOpc = W65816::DEC_abs;
                  }
                }
              }
            }
          }
          // Check for shl/lshr by 1 (ASL/LSR)
          else if (Value.getOpcode() == ISD::SHL || Value.getOpcode() == ISD::SRL) {
            SDValue Src = Value.getOperand(0);
            SDValue Amt = Value.getOperand(1);

            if (ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Amt)) {
              if (CN->getZExtValue() == 1 && Src.getOpcode() == ISD::LOAD) {
                LoadVal = Src;
                MemOpc = (Value.getOpcode() == ISD::SHL) ? W65816::ASL_abs : W65816::LSR_abs;
              }
            }
          }

          // If we found a valid pattern, check that load is from the same address
          if (MemOpc != 0 && LoadVal.getNode()) {
            LoadSDNode *LD = cast<LoadSDNode>(LoadVal.getNode());
            SDValue LoadAddr = LD->getBasePtr();

            // Check if load address matches store address (same global)
            if (LoadAddr.getOpcode() == W65816ISD::WRAPPER) {
              SDValue LoadInner = LoadAddr.getOperand(0);
              if (GlobalAddressSDNode *LoadGA = dyn_cast<GlobalAddressSDNode>(LoadInner)) {
                if (LoadGA->getGlobal() == GA->getGlobal() &&
                    LoadGA->getOffset() == GA->getOffset()) {
                  // Check that load has only one use (the operation) AND
                  // the operation result has only one use (the store)
                  // This ensures we're not losing a value that's used elsewhere
                  if (LoadVal.hasOneUse() && Value.hasOneUse()) {
                    // Use direct page variant if applicable
                    if (isDirectPageGlobal(GA->getGlobal())) {
                      switch (MemOpc) {
                        case W65816::INC_abs: MemOpc = W65816::INC_dp; break;
                        case W65816::DEC_abs: MemOpc = W65816::DEC_dp; break;
                        case W65816::ASL_abs: MemOpc = W65816::ASL_dp; break;
                        case W65816::LSR_abs: MemOpc = W65816::LSR_dp; break;
                      }
                      SDValue TargetAddr = CurDAG->getTargetGlobalAddress(
                          GA->getGlobal(), DL, MVT::i8, GA->getOffset());
                      // Chain through the load's chain for proper ordering
                      SDValue Ops[] = {TargetAddr, LD->getChain()};
                      MachineSDNode *MemOp =
                          CurDAG->getMachineNode(MemOpc, DL, MVT::Other, Ops);
                      CurDAG->setNodeMemRefs(MemOp, {ST->getMemOperand()});
                      ReplaceNode(N, MemOp);
                      return;
                    }
                    // Use absolute addressing
                    SDValue TargetAddr = CurDAG->getTargetGlobalAddress(
                        GA->getGlobal(), DL, MVT::i16, GA->getOffset());
                    SDValue Ops[] = {TargetAddr, LD->getChain()};
                    MachineSDNode *MemOp =
                        CurDAG->getMachineNode(MemOpc, DL, MVT::Other, Ops);
                    CurDAG->setNodeMemRefs(MemOp, {ST->getMemOperand()});
                    ReplaceNode(N, MemOp);
                    return;
                  }
                }
              }
            }
          }
        }
      }

      // Check for frame index - use stack-relative addressing
      if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(Addr)) {
        int FI = FIN->getIndex();
        SDValue TFI = CurDAG->getTargetFrameIndex(FI, MVT::i16);

        // Emit STA_sr: store A to stack-relative address
        SDValue Ops[] = {Value, TFI, Chain};
        MachineSDNode *Store =
            CurDAG->getMachineNode(W65816::STA_sr, DL, MVT::Other, Ops);

        CurDAG->setNodeMemRefs(Store, {ST->getMemOperand()});
        ReplaceNode(N, Store);
        return;
      }

      // Check for direct page or far addressing: (store val, (wrapper GA))
      if (Addr.getOpcode() == W65816ISD::WRAPPER) {
        SDValue Inner = Addr.getOperand(0);
        if (GlobalAddressSDNode *GA = dyn_cast<GlobalAddressSDNode>(Inner)) {
          if (isDirectPageGlobal(GA->getGlobal())) {
            // Use direct page store (2-byte instruction)
            // The address is 8-bit, so we create a target global with i8 type
            SDValue TargetAddr = CurDAG->getTargetGlobalAddress(
                GA->getGlobal(), DL, MVT::i8, GA->getOffset());

            SDValue Ops[] = {Value, TargetAddr, Chain};
            MachineSDNode *Store =
                CurDAG->getMachineNode(W65816::STA_dp, DL, MVT::Other, Ops);

            CurDAG->setNodeMemRefs(Store, {ST->getMemOperand()});
            ReplaceNode(N, Store);
            return;
          }
          if (isFarGlobal(GA->getGlobal())) {
            // Use long (24-bit) addressing for far globals
            SDValue TargetAddr = CurDAG->getTargetGlobalAddress(
                GA->getGlobal(), DL, MVT::i32, GA->getOffset());

            SDValue Ops[] = {Value, TargetAddr, Chain};
            MachineSDNode *Store =
                CurDAG->getMachineNode(W65816::STA_long, DL, MVT::Other, Ops);

            CurDAG->setNodeMemRefs(Store, {ST->getMemOperand()});
            ReplaceNode(N, Store);
            return;
          }
        }
      }

      // Check for indexed addressing: (store val, (add (wrapper GA), index))
      if (Addr.getOpcode() == ISD::ADD) {
        SDValue LHS = Addr.getOperand(0);
        SDValue RHS = Addr.getOperand(1);

        // Check for (add (wrapper GA), index) pattern
        SDValue Base;
        SDValue Index;
        if (LHS.getOpcode() == W65816ISD::WRAPPER) {
          Base = LHS.getOperand(0);
          Index = RHS;
        } else if (RHS.getOpcode() == W65816ISD::WRAPPER) {
          Base = RHS.getOperand(0);
          Index = LHS;
        }

        if (Base.getNode() && Index.getNode()) {
          if (GlobalAddressSDNode *GA = dyn_cast<GlobalAddressSDNode>(Base)) {
            // Check if index is a constant - can fold into address
            if (ConstantSDNode *CI = dyn_cast<ConstantSDNode>(Index)) {
              int64_t Offset = GA->getOffset() + CI->getSExtValue();

              if (isFarGlobal(GA->getGlobal())) {
                // Use long addressing with folded offset
                SDValue TargetAddr = CurDAG->getTargetGlobalAddress(
                    GA->getGlobal(), DL, MVT::i32, Offset);
                SDValue Ops[] = {Value, TargetAddr, Chain};
                MachineSDNode *Store =
                    CurDAG->getMachineNode(W65816::STA_long, DL, MVT::Other, Ops);
                CurDAG->setNodeMemRefs(Store, {ST->getMemOperand()});
                ReplaceNode(N, Store);
                return;
              }
              // Regular absolute with folded offset
              SDValue TargetAddr = CurDAG->getTargetGlobalAddress(
                  GA->getGlobal(), DL, MVT::i16, Offset);
              SDValue Ops[] = {Value, TargetAddr, Chain};
              MachineSDNode *Store =
                  CurDAG->getMachineNode(W65816::STA_abs, DL, MVT::Other, Ops);
              CurDAG->setNodeMemRefs(Store, {ST->getMemOperand()});
              ReplaceNode(N, Store);
              return;
            }

            // Variable index - use indexed addressing
            if (isFarGlobal(GA->getGlobal())) {
              // Use long indexed for far globals
              SDValue TargetAddr = CurDAG->getTargetGlobalAddress(
                  GA->getGlobal(), DL, MVT::i32, GA->getOffset());
              SDValue Ops[] = {Value, TargetAddr, Index, Chain};
              MachineSDNode *Store =
                  CurDAG->getMachineNode(W65816::STAindexedLongX, DL, MVT::Other, Ops);
              CurDAG->setNodeMemRefs(Store, {ST->getMemOperand()});
              ReplaceNode(N, Store);
              return;
            }

            // Regular absolute indexed
            SDValue TargetAddr = CurDAG->getTargetGlobalAddress(
                GA->getGlobal(), DL, MVT::i16, GA->getOffset());

            // Check if storing zero - use STZ instead of STA
            if (ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Value)) {
              if (CN->isZero()) {
                SDValue Ops[] = {TargetAddr, Index, Chain};
                MachineSDNode *Store =
                    CurDAG->getMachineNode(W65816::STZindexedX, DL, MVT::Other, Ops);
                CurDAG->setNodeMemRefs(Store, {ST->getMemOperand()});
                ReplaceNode(N, Store);
                return;
              }
            }

            // Emit STAindexedX pseudo: (val, addr, idx)
            SDValue Ops[] = {Value, TargetAddr, Index, Chain};
            MachineSDNode *Store =
                CurDAG->getMachineNode(W65816::STAindexedX, DL, MVT::Other, Ops);

            CurDAG->setNodeMemRefs(Store, {ST->getMemOperand()});
            ReplaceNode(N, Store);
            return;
          }
        }
      }

      // Check for DP indirect indexed Y store: (store val, (add (load (wrapper GA_dp)), offset))
      // This is ptr[i] = val where ptr is stored in direct page.
      // We can use STA ($dp),Y instead of stack-relative indirect.
      if (Addr.getOpcode() == ISD::ADD) {
        SDValue LHS = Addr.getOperand(0);
        SDValue RHS = Addr.getOperand(1);

        // Check for (add (load (wrapper GA_dp)), offset)
        SDValue PtrSrc;
        SDValue Offset;
        if (LHS.getOpcode() == ISD::LOAD) {
          PtrSrc = LHS;
          Offset = RHS;
        } else if (RHS.getOpcode() == ISD::LOAD) {
          PtrSrc = RHS;
          Offset = LHS;
        }

        if (PtrSrc.getNode()) {
          LoadSDNode *PtrLoad = cast<LoadSDNode>(PtrSrc.getNode());
          SDValue PtrAddr = PtrLoad->getBasePtr();

          if (PtrAddr.getOpcode() == W65816ISD::WRAPPER) {
            SDValue Inner = PtrAddr.getOperand(0);
            if (GlobalAddressSDNode *GA = dyn_cast<GlobalAddressSDNode>(Inner)) {
              if (isDirectPageGlobal(GA->getGlobal())) {
                // Use DP indirect indexed Y: STA ($dp),Y
                SDValue TargetAddr = CurDAG->getTargetGlobalAddress(
                    GA->getGlobal(), DL, MVT::i8, GA->getOffset());

                // Use STAindexedDPY pseudo which handles moving offset to Y
                SDValue PtrChain = PtrLoad->getChain();
                SDValue Ops[] = {Value, TargetAddr, Offset, PtrChain};
                MachineSDNode *Store =
                    CurDAG->getMachineNode(W65816::STAindexedDPY, DL, MVT::Other, Ops);

                CurDAG->setNodeMemRefs(Store, {ST->getMemOperand()});
                ReplaceNode(N, Store);
                return;
              }
            }
          }
        }
      }

      // Check for frame index + constant offset: (store val, (add frameindex, const))
      // This is the common pattern for local array/struct access: arr[i] = val
      // Use simple STA_sr with combined offset
      if (Addr.getOpcode() == ISD::ADD) {
        SDValue LHS = Addr.getOperand(0);
        SDValue RHS = Addr.getOperand(1);

        // Check for (add frameindex, constant) pattern
        FrameIndexSDNode *FIN = nullptr;
        ConstantSDNode *CN = nullptr;

        if (isa<FrameIndexSDNode>(LHS) && isa<ConstantSDNode>(RHS)) {
          FIN = cast<FrameIndexSDNode>(LHS);
          CN = cast<ConstantSDNode>(RHS);
        } else if (isa<FrameIndexSDNode>(RHS) && isa<ConstantSDNode>(LHS)) {
          FIN = cast<FrameIndexSDNode>(RHS);
          CN = cast<ConstantSDNode>(LHS);
        }

        if (FIN && CN) {
          // Use STA_sr with frame index + constant offset
          // Frame lowering will resolve this to the final stack offset
          int FI = FIN->getIndex();
          int64_t Offset = CN->getSExtValue();
          SDValue TFI = CurDAG->getTargetFrameIndex(FI, MVT::i16);

          // Create a new frame index with the offset applied
          // We encode the offset as an additional operand that will be
          // added during frame lowering
          SDValue OffsetVal = CurDAG->getTargetConstant(Offset, DL, MVT::i16);
          SDValue Ops[] = {Value, TFI, OffsetVal, Chain};
          MachineSDNode *Store =
              CurDAG->getMachineNode(W65816::STA_sr_off, DL, MVT::Other, Ops);

          CurDAG->setNodeMemRefs(Store, {ST->getMemOperand()});
          ReplaceNode(N, Store);
          return;
        }
      }

      // Check for frame index + variable offset: (store val, (add frameindex, reg))
      // This handles arr[i] = val where arr is on stack and i is a variable
      // We need to compute the frame address first, then use indexed indirect
      if (Addr.getOpcode() == ISD::ADD) {
        SDValue LHS = Addr.getOperand(0);
        SDValue RHS = Addr.getOperand(1);

        // Check for (add frameindex, variable) pattern
        FrameIndexSDNode *FIN = nullptr;
        SDValue VarOffset;

        if (isa<FrameIndexSDNode>(LHS) && !isa<ConstantSDNode>(RHS)) {
          FIN = cast<FrameIndexSDNode>(LHS);
          VarOffset = RHS;
        } else if (isa<FrameIndexSDNode>(RHS) && !isa<ConstantSDNode>(LHS)) {
          FIN = cast<FrameIndexSDNode>(RHS);
          VarOffset = LHS;
        }

        if (FIN) {
          // First compute the frame address using LEA_fi
          int FI = FIN->getIndex();
          SDValue TFI = CurDAG->getTargetFrameIndex(FI, MVT::i16);
          MachineSDNode *LEA = CurDAG->getMachineNode(W65816::LEA_fi, DL, MVT::i16, TFI);
          SDValue BaseAddr = SDValue(LEA, 0);

          // Now use STAindirectIdx with the computed address and variable offset
          MachineFunction &MF = CurDAG->getMachineFunction();
          MachineFrameInfo &MFI = MF.getFrameInfo();

          int StackFI = MFI.CreateStackObject(2, Align(2), false);
          SDValue StackSlot = CurDAG->getTargetFrameIndex(StackFI, MVT::i16);

          SDValue Ops[] = {Value, StackSlot, BaseAddr, VarOffset, Chain};
          MachineSDNode *Store =
              CurDAG->getMachineNode(W65816::STAindirectIdx, DL, MVT::Other, Ops);

          CurDAG->setNodeMemRefs(Store, {ST->getMemOperand()});
          ReplaceNode(N, Store);
          return;
        }
      }

      // Check for indexed pointer store: (store val, (add ptr, offset))
      // where ptr is a register and offset is computed (not a frame index case)
      if (Addr.getOpcode() == ISD::ADD) {
        SDValue LHS = Addr.getOperand(0);
        SDValue RHS = Addr.getOperand(1);

        // Check if this is (add ptr, byte_offset) where neither is a global
        // and not a frame index (those are handled above)
        bool LHSIsWrapper = (LHS.getOpcode() == W65816ISD::WRAPPER);
        bool RHSIsWrapper = (RHS.getOpcode() == W65816ISD::WRAPPER);
        bool LHSIsFrameIndex = isa<FrameIndexSDNode>(LHS);
        bool RHSIsFrameIndex = isa<FrameIndexSDNode>(RHS);

        if (!LHSIsWrapper && !RHSIsWrapper && !LHSIsFrameIndex && !RHSIsFrameIndex) {
          // This is indexed pointer store: ptr[i] = val
          MachineFunction &MF = CurDAG->getMachineFunction();
          MachineFrameInfo &MFI = MF.getFrameInfo();

          int FI = MFI.CreateStackObject(2, Align(2), false);
          SDValue StackSlot = CurDAG->getTargetFrameIndex(FI, MVT::i16);

          // Use STAindirectIdx pseudo
          SDValue Ops[] = {Value, StackSlot, LHS, RHS, Chain};
          MachineSDNode *Store =
              CurDAG->getMachineNode(W65816::STAindirectIdx, DL, MVT::Other, Ops);

          CurDAG->setNodeMemRefs(Store, {ST->getMemOperand()});
          ReplaceNode(N, Store);
          return;
        }
      }

      // Check for DP indirect store: (store val, (load (wrapper GA_dp)))
      // This is storing through a pointer that's in direct page.
      // We can use STA ($dp) instead of stack-relative indirect.
      if (Addr.getOpcode() == ISD::LOAD) {
        LoadSDNode *PtrLoad = cast<LoadSDNode>(Addr.getNode());
        SDValue PtrAddr = PtrLoad->getBasePtr();

        // Check if the pointer is loaded from a direct page global
        if (PtrAddr.getOpcode() == W65816ISD::WRAPPER) {
          SDValue Inner = PtrAddr.getOperand(0);
          if (GlobalAddressSDNode *GA = dyn_cast<GlobalAddressSDNode>(Inner)) {
            if (isDirectPageGlobal(GA->getGlobal())) {
              // Use DP indirect: STA ($dp)
              SDValue TargetAddr = CurDAG->getTargetGlobalAddress(
                  GA->getGlobal(), DL, MVT::i8, GA->getOffset());

              // Chain through the pointer load
              SDValue PtrChain = PtrLoad->getChain();
              SDValue Ops[] = {Value, TargetAddr, PtrChain};
              MachineSDNode *Store =
                  CurDAG->getMachineNode(W65816::STA_dpInd, DL, MVT::Other, Ops);

              CurDAG->setNodeMemRefs(Store, {ST->getMemOperand()});
              ReplaceNode(N, Store);
              return;
            }
          }
        }
      }

      // Check for store to constant address (from inttoptr)
      // This handles volatile stores like: store volatile i8 %v, ptr inttoptr (i16 8469 to ptr)
      // Use direct absolute addressing instead of indirect
      if (ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Addr)) {
        uint64_t ConstAddr = CN->getZExtValue() & 0xFFFF;
        SDValue TargetAddr = CurDAG->getTargetConstant(ConstAddr, DL, MVT::i16);
        SDValue Ops[] = {Value, TargetAddr, Chain};
        MachineSDNode *Store =
            CurDAG->getMachineNode(W65816::STA_abs, DL, MVT::Other, Ops);
        CurDAG->setNodeMemRefs(Store, {ST->getMemOperand()});
        ReplaceNode(N, Store);
        return;
      }

      // Check for store through a pointer in a register (e.g., *ptr = val)
      // If Addr is not a frame index, wrapper, add pattern, or constant, it's a register
      // We need to use stack-relative indirect addressing:
      // 1. Store the pointer to a stack slot
      // 2. Use STA (offset,S),Y with Y=0 to store through it
      if (!isa<FrameIndexSDNode>(Addr) &&
          Addr.getOpcode() != W65816ISD::WRAPPER &&
          Addr.getOpcode() != ISD::ADD) {
        // The address is in a register - use stack-relative indirect
        MachineFunction &MF = CurDAG->getMachineFunction();
        MachineFrameInfo &MFI = MF.getFrameInfo();

        // Create a stack slot to hold the pointer (2 bytes, aligned to 2)
        int FI = MFI.CreateStackObject(2, Align(2), false);
        SDValue StackSlot = CurDAG->getTargetFrameIndex(FI, MVT::i16);

        // Use STAindirect pseudo which will be expanded after register allocation
        SDValue ZeroIdx = CurDAG->getTargetConstant(0, DL, MVT::i16);
        SDValue Ops[] = {Value, StackSlot, Addr, ZeroIdx, Chain};
        MachineSDNode *Store =
            CurDAG->getMachineNode(W65816::STAindirect, DL, MVT::Other, Ops);

        CurDAG->setNodeMemRefs(Store, {ST->getMemOperand()});
        ReplaceNode(N, Store);
        return;
      }
    }

    // Handle 8-bit truncating stores (truncstorei8) through pointers
    // These need mode switching: SEP #$20, store, REP #$20
    if (ST->getMemoryVT() == MVT::i8 && ST->isTruncatingStore()) {

      // Check for indexed GLOBAL access: (store i8, (add (wrapper GA), index))
      // This handles global_array[i] = val for byte arrays
      if (Addr.getOpcode() == ISD::ADD) {
        SDValue LHS = Addr.getOperand(0);
        SDValue RHS = Addr.getOperand(1);

        // Check for (add (wrapper GA), index) pattern
        SDValue Base;
        SDValue Index;
        if (LHS.getOpcode() == W65816ISD::WRAPPER) {
          Base = LHS.getOperand(0);
          Index = RHS;
        } else if (RHS.getOpcode() == W65816ISD::WRAPPER) {
          Base = RHS.getOperand(0);
          Index = LHS;
        }

        if (Base.getNode() && Index.getNode()) {
          if (GlobalAddressSDNode *GA = dyn_cast<GlobalAddressSDNode>(Base)) {
            // Check if index is a constant - can fold into address
            if (ConstantSDNode *CI = dyn_cast<ConstantSDNode>(Index)) {
              int64_t Offset = GA->getOffset() + CI->getSExtValue();
              // Use STA8_abs with folded offset
              SDValue TargetAddr = CurDAG->getTargetGlobalAddress(
                  GA->getGlobal(), DL, MVT::i16, Offset);
              SDValue Ops[] = {Value, TargetAddr, Chain};
              MachineSDNode *Store =
                  CurDAG->getMachineNode(W65816::STA8_abs, DL, MVT::Other, Ops);
              CurDAG->setNodeMemRefs(Store, {ST->getMemOperand()});
              ReplaceNode(N, Store);
              return;
            }

            // Variable index - use STA8indexedX pseudo
            SDValue TargetAddr = CurDAG->getTargetGlobalAddress(
                GA->getGlobal(), DL, MVT::i16, GA->getOffset());
            SDValue Ops[] = {Value, TargetAddr, Index, Chain};
            MachineSDNode *Store =
                CurDAG->getMachineNode(W65816::STA8indexedX, DL, MVT::Other, Ops);
            CurDAG->setNodeMemRefs(Store, {ST->getMemOperand()});
            ReplaceNode(N, Store);
            return;
          }
        }
      }

      // Check for indexed pointer access: (store i8, (add ptr, offset))
      // This handles ptr[i] = val for byte arrays where ptr is in a register
      if (Addr.getOpcode() == ISD::ADD) {
        SDValue LHS = Addr.getOperand(0);
        SDValue RHS = Addr.getOperand(1);

        // Check if this is (add ptr, offset) where neither is a global
        bool LHSIsWrapper = (LHS.getOpcode() == W65816ISD::WRAPPER);
        bool RHSIsWrapper = (RHS.getOpcode() == W65816ISD::WRAPPER);

        if (!LHSIsWrapper && !RHSIsWrapper) {
          // This is indexed pointer access for byte array: ptr[i] = val
          // LHS is the base pointer, RHS is the byte offset
          MachineFunction &MF = CurDAG->getMachineFunction();
          MachineFrameInfo &MFI = MF.getFrameInfo();

          int FI = MFI.CreateStackObject(2, Align(2), false);
          SDValue StackSlot = CurDAG->getTargetFrameIndex(FI, MVT::i16);

          // Use STA8indirectIdx pseudo
          SDValue Ops[] = {Value, StackSlot, LHS, RHS, Chain};
          MachineSDNode *Store =
              CurDAG->getMachineNode(W65816::STA8indirectIdx, DL, MVT::Other, Ops);

          CurDAG->setNodeMemRefs(Store, {ST->getMemOperand()});
          ReplaceNode(N, Store);
          return;
        }
      }

      // Check for 8-bit store to constant address (from inttoptr)
      // This handles volatile stores like: store volatile i8 %v, ptr inttoptr (i16 8469 to ptr)
      if (ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Addr)) {
        uint64_t ConstAddr = CN->getZExtValue() & 0xFFFF;
        SDValue TargetAddr = CurDAG->getTargetConstant(ConstAddr, DL, MVT::i16);
        SDValue Ops[] = {Value, TargetAddr, Chain};
        MachineSDNode *Store =
            CurDAG->getMachineNode(W65816::STA8_abs, DL, MVT::Other, Ops);
        CurDAG->setNodeMemRefs(Store, {ST->getMemOperand()});
        ReplaceNode(N, Store);
        return;
      }

      // Check for simple pointer dereference through register
      // This handles cases like *(u8*)ptr = val where ptr is in a register
      if (!isa<FrameIndexSDNode>(Addr) &&
          Addr.getOpcode() != W65816ISD::WRAPPER &&
          Addr.getOpcode() != ISD::ADD &&
          !isa<GlobalAddressSDNode>(Addr) &&
          !isa<ConstantSDNode>(Addr)) {

        // The address is in a register - use stack-relative indirect with mode switch
        MachineFunction &MF = CurDAG->getMachineFunction();
        MachineFrameInfo &MFI = MF.getFrameInfo();

        // Create a stack slot to hold the pointer (2 bytes, aligned to 2)
        int FI = MFI.CreateStackObject(2, Align(2), false);
        SDValue StackSlot = CurDAG->getTargetFrameIndex(FI, MVT::i16);

        // Use STA8indirect pseudo which will:
        // 1. Store Addr to stack slot
        // 2. SEP #$20
        // 3. LDY #0
        // 4. STA (FI,S),Y
        // 5. REP #$20
        SDValue ZeroIdx = CurDAG->getTargetConstant(0, DL, MVT::i16);

        SDValue Ops[] = {Value, StackSlot, Addr, ZeroIdx, Chain};
        MachineSDNode *Store =
            CurDAG->getMachineNode(W65816::STA8indirect, DL, MVT::Other, Ops);

        CurDAG->setNodeMemRefs(Store, {ST->getMemOperand()});
        ReplaceNode(N, Store);
        return;
      }
    }
    break;
  }

  case ISD::LOAD: {
    // Check if loading from a frame index - use stack-relative addressing
    LoadSDNode *LD = cast<LoadSDNode>(N);
    SDValue Chain = LD->getChain();
    SDValue Addr = LD->getBasePtr();

    // Only handle simple loads of i16
    if (LD->getMemoryVT() == MVT::i16 && LD->getExtensionType() == ISD::NON_EXTLOAD) {
      // Check for frame index - use stack-relative addressing
      if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(Addr)) {
        int FI = FIN->getIndex();
        SDValue TFI = CurDAG->getTargetFrameIndex(FI, MVT::i16);

        // Emit LDA_sr: load A from stack-relative address
        SDValue Ops[] = {TFI, Chain};
        SDVTList VTs = CurDAG->getVTList(MVT::i16, MVT::Other);
        MachineSDNode *Load =
            CurDAG->getMachineNode(W65816::LDA_sr, DL, VTs, Ops);

        CurDAG->setNodeMemRefs(Load, {LD->getMemOperand()});
        ReplaceNode(N, Load);
        return;
      }

      // Check for direct page or far addressing: (load (wrapper GA))
      if (Addr.getOpcode() == W65816ISD::WRAPPER) {
        SDValue Inner = Addr.getOperand(0);
        if (GlobalAddressSDNode *GA = dyn_cast<GlobalAddressSDNode>(Inner)) {
          if (isDirectPageGlobal(GA->getGlobal())) {
            // Use direct page load (2-byte instruction)
            SDValue TargetAddr = CurDAG->getTargetGlobalAddress(
                GA->getGlobal(), DL, MVT::i8, GA->getOffset());

            SDValue Ops[] = {TargetAddr, Chain};
            SDVTList VTs = CurDAG->getVTList(MVT::i16, MVT::Other);
            MachineSDNode *Load =
                CurDAG->getMachineNode(W65816::LDA_dp, DL, VTs, Ops);

            CurDAG->setNodeMemRefs(Load, {LD->getMemOperand()});
            ReplaceNode(N, Load);
            return;
          }
          if (isFarGlobal(GA->getGlobal())) {
            // Use long (24-bit) addressing for far globals
            // The 24-bit address is constructed from the global address
            SDValue TargetAddr = CurDAG->getTargetGlobalAddress(
                GA->getGlobal(), DL, MVT::i32, GA->getOffset());

            SDValue Ops[] = {TargetAddr, Chain};
            SDVTList VTs = CurDAG->getVTList(MVT::i16, MVT::Other);
            MachineSDNode *Load =
                CurDAG->getMachineNode(W65816::LDA_long, DL, VTs, Ops);

            CurDAG->setNodeMemRefs(Load, {LD->getMemOperand()});
            ReplaceNode(N, Load);
            return;
          }
        }
      }

      // Check for indexed addressing: (load (add (wrapper GA), index))
      if (Addr.getOpcode() == ISD::ADD) {
        SDValue LHS = Addr.getOperand(0);
        SDValue RHS = Addr.getOperand(1);

        // Check for (add (wrapper GA), index) pattern
        SDValue Base;
        SDValue Index;
        if (LHS.getOpcode() == W65816ISD::WRAPPER) {
          Base = LHS.getOperand(0);
          Index = RHS;
        } else if (RHS.getOpcode() == W65816ISD::WRAPPER) {
          Base = RHS.getOperand(0);
          Index = LHS;
        }

        if (Base.getNode() && Index.getNode()) {
          if (GlobalAddressSDNode *GA = dyn_cast<GlobalAddressSDNode>(Base)) {
            // Check if index is a constant - can fold into address
            if (ConstantSDNode *CI = dyn_cast<ConstantSDNode>(Index)) {
              int64_t Offset = GA->getOffset() + CI->getSExtValue();

              if (isFarGlobal(GA->getGlobal())) {
                // Use long addressing with folded offset
                SDValue TargetAddr = CurDAG->getTargetGlobalAddress(
                    GA->getGlobal(), DL, MVT::i32, Offset);
                SDValue Ops[] = {TargetAddr, Chain};
                SDVTList VTs = CurDAG->getVTList(MVT::i16, MVT::Other);
                MachineSDNode *Load =
                    CurDAG->getMachineNode(W65816::LDA_long, DL, VTs, Ops);
                CurDAG->setNodeMemRefs(Load, {LD->getMemOperand()});
                ReplaceNode(N, Load);
                return;
              }
              // Regular absolute with folded offset
              SDValue TargetAddr = CurDAG->getTargetGlobalAddress(
                  GA->getGlobal(), DL, MVT::i16, Offset);
              SDValue Ops[] = {TargetAddr, Chain};
              SDVTList VTs = CurDAG->getVTList(MVT::i16, MVT::Other);
              MachineSDNode *Load =
                  CurDAG->getMachineNode(W65816::LDA_abs, DL, VTs, Ops);
              CurDAG->setNodeMemRefs(Load, {LD->getMemOperand()});
              ReplaceNode(N, Load);
              return;
            }

            // Variable index - use indexed addressing
            if (isFarGlobal(GA->getGlobal())) {
              // Use long indexed for far globals
              SDValue TargetAddr = CurDAG->getTargetGlobalAddress(
                  GA->getGlobal(), DL, MVT::i32, GA->getOffset());
              SDValue Ops[] = {TargetAddr, Index, Chain};
              SDVTList VTs = CurDAG->getVTList(MVT::i16, MVT::Other);
              MachineSDNode *Load =
                  CurDAG->getMachineNode(W65816::LDAindexedLongX, DL, VTs, Ops);
              CurDAG->setNodeMemRefs(Load, {LD->getMemOperand()});
              ReplaceNode(N, Load);
              return;
            }

            // Regular absolute indexed
            SDValue TargetAddr = CurDAG->getTargetGlobalAddress(
                GA->getGlobal(), DL, MVT::i16, GA->getOffset());

            // Emit LDAindexedX pseudo: (dst, addr, idx)
            // This pseudo will be expanded after register allocation
            // to properly handle register conflicts
            SDValue Ops[] = {TargetAddr, Index, Chain};
            SDVTList VTs = CurDAG->getVTList(MVT::i16, MVT::Other);
            MachineSDNode *Load =
                CurDAG->getMachineNode(W65816::LDAindexedX, DL, VTs, Ops);

            CurDAG->setNodeMemRefs(Load, {LD->getMemOperand()});
            ReplaceNode(N, Load);
            return;
          }
        }
      }

      // Check for DP indirect indexed Y: (load (add (load (wrapper GA_dp)), offset))
      // This is ptr[i] where ptr is stored in direct page.
      // We can use LDA ($dp),Y instead of stack-relative indirect.
      if (Addr.getOpcode() == ISD::ADD) {
        SDValue LHS = Addr.getOperand(0);
        SDValue RHS = Addr.getOperand(1);

        // Check for (add (load (wrapper GA_dp)), offset)
        SDValue PtrSrc;
        SDValue Offset;
        if (LHS.getOpcode() == ISD::LOAD) {
          PtrSrc = LHS;
          Offset = RHS;
        } else if (RHS.getOpcode() == ISD::LOAD) {
          PtrSrc = RHS;
          Offset = LHS;
        }

        if (PtrSrc.getNode()) {
          LoadSDNode *PtrLoad = cast<LoadSDNode>(PtrSrc.getNode());
          SDValue PtrAddr = PtrLoad->getBasePtr();

          if (PtrAddr.getOpcode() == W65816ISD::WRAPPER) {
            SDValue Inner = PtrAddr.getOperand(0);
            if (GlobalAddressSDNode *GA = dyn_cast<GlobalAddressSDNode>(Inner)) {
              if (isDirectPageGlobal(GA->getGlobal())) {
                // Use DP indirect indexed Y: LDA ($dp),Y
                SDValue TargetAddr = CurDAG->getTargetGlobalAddress(
                    GA->getGlobal(), DL, MVT::i8, GA->getOffset());

                // Need to move offset to Y register first
                // Use LDAindexedDPY pseudo which handles this
                SDValue PtrChain = PtrLoad->getChain();
                SDValue Ops[] = {TargetAddr, Offset, PtrChain};
                SDVTList VTs = CurDAG->getVTList(MVT::i16, MVT::Other);
                MachineSDNode *Load =
                    CurDAG->getMachineNode(W65816::LDAindexedDPY, DL, VTs, Ops);

                CurDAG->setNodeMemRefs(Load, {LD->getMemOperand()});
                ReplaceNode(N, Load);
                return;
              }
            }
          }
        }
      }

      // Check for frame index + constant offset: (load (add frameindex, const))
      // This is the common pattern for local array/struct access: arr[i]
      // Use simple LDA_sr with combined offset
      if (Addr.getOpcode() == ISD::ADD) {
        SDValue LHS = Addr.getOperand(0);
        SDValue RHS = Addr.getOperand(1);

        // Check for (add frameindex, constant) pattern
        FrameIndexSDNode *FIN = nullptr;
        ConstantSDNode *CN = nullptr;

        if (isa<FrameIndexSDNode>(LHS) && isa<ConstantSDNode>(RHS)) {
          FIN = cast<FrameIndexSDNode>(LHS);
          CN = cast<ConstantSDNode>(RHS);
        } else if (isa<FrameIndexSDNode>(RHS) && isa<ConstantSDNode>(LHS)) {
          FIN = cast<FrameIndexSDNode>(RHS);
          CN = cast<ConstantSDNode>(LHS);
        }

        if (FIN && CN) {
          // Use LDA_sr_off with frame index + constant offset
          // Frame lowering will resolve this to the final stack offset
          int FI = FIN->getIndex();
          int64_t Offset = CN->getSExtValue();
          SDValue TFI = CurDAG->getTargetFrameIndex(FI, MVT::i16);
          SDValue OffsetVal = CurDAG->getTargetConstant(Offset, DL, MVT::i16);
          SDValue Ops[] = {TFI, OffsetVal, Chain};
          SDVTList VTs = CurDAG->getVTList(MVT::i16, MVT::Other);
          MachineSDNode *Load =
              CurDAG->getMachineNode(W65816::LDA_sr_off, DL, VTs, Ops);

          CurDAG->setNodeMemRefs(Load, {LD->getMemOperand()});
          ReplaceNode(N, Load);
          return;
        }
      }

      // Check for frame index + variable offset: (load (add frameindex, reg))
      // This handles arr[i] where arr is on stack and i is a variable
      // We need to compute the frame address first, then use indexed indirect
      if (Addr.getOpcode() == ISD::ADD) {
        SDValue LHS = Addr.getOperand(0);
        SDValue RHS = Addr.getOperand(1);

        // Check for (add frameindex, variable) pattern
        FrameIndexSDNode *FIN = nullptr;
        SDValue VarOffset;

        if (isa<FrameIndexSDNode>(LHS) && !isa<ConstantSDNode>(RHS)) {
          FIN = cast<FrameIndexSDNode>(LHS);
          VarOffset = RHS;
        } else if (isa<FrameIndexSDNode>(RHS) && !isa<ConstantSDNode>(LHS)) {
          FIN = cast<FrameIndexSDNode>(RHS);
          VarOffset = LHS;
        }

        if (FIN) {
          // First compute the frame address using LEA_fi
          int FI = FIN->getIndex();
          SDValue TFI = CurDAG->getTargetFrameIndex(FI, MVT::i16);
          MachineSDNode *LEA = CurDAG->getMachineNode(W65816::LEA_fi, DL, MVT::i16, TFI);
          SDValue BaseAddr = SDValue(LEA, 0);

          // Now use LDAindirectIdx with the computed address and variable offset
          MachineFunction &MF = CurDAG->getMachineFunction();
          MachineFrameInfo &MFI = MF.getFrameInfo();

          int StackFI = MFI.CreateStackObject(2, Align(2), false);
          SDValue StackSlot = CurDAG->getTargetFrameIndex(StackFI, MVT::i16);

          SDValue Ops[] = {StackSlot, BaseAddr, VarOffset, Chain};
          SDVTList VTs = CurDAG->getVTList(MVT::i16, MVT::Other);
          MachineSDNode *Load =
              CurDAG->getMachineNode(W65816::LDAindirectIdx, DL, VTs, Ops);

          CurDAG->setNodeMemRefs(Load, {LD->getMemOperand()});
          ReplaceNode(N, Load);
          return;
        }
      }

      // Check for indexed pointer access: (load (add ptr, offset))
      // where ptr is a register and offset is computed (e.g., i*2 for i16 arrays)
      // This handles ptr[i] where ptr is in a register
      if (Addr.getOpcode() == ISD::ADD) {
        SDValue LHS = Addr.getOperand(0);
        SDValue RHS = Addr.getOperand(1);

        // Check if this is (add ptr, byte_offset) where neither is a global
        // and not a frame index (those are handled above)
        bool LHSIsWrapper = (LHS.getOpcode() == W65816ISD::WRAPPER);
        bool RHSIsWrapper = (RHS.getOpcode() == W65816ISD::WRAPPER);
        bool LHSIsFrameIndex = isa<FrameIndexSDNode>(LHS);
        bool RHSIsFrameIndex = isa<FrameIndexSDNode>(RHS);

        if (!LHSIsWrapper && !RHSIsWrapper && !LHSIsFrameIndex && !RHSIsFrameIndex) {
          // This is indexed pointer access: ptr[i]
          // LHS is typically the base pointer, RHS is the byte offset
          // We'll use stack-relative indirect indexed addressing:
          // 1. Store base pointer to stack slot
          // 2. Load byte offset to Y
          // 3. Use LDA (offset,S),Y

          MachineFunction &MF = CurDAG->getMachineFunction();
          MachineFrameInfo &MFI = MF.getFrameInfo();

          int FI = MFI.CreateStackObject(2, Align(2), false);
          SDValue StackSlot = CurDAG->getTargetFrameIndex(FI, MVT::i16);

          // Use LDAindirectIdx pseudo: stores LHS (ptr) to stack, puts RHS (offset) in Y
          // Then uses LDA (offset,S),Y
          SDValue Ops[] = {StackSlot, LHS, RHS, Chain};
          SDVTList VTs = CurDAG->getVTList(MVT::i16, MVT::Other);
          MachineSDNode *Load =
              CurDAG->getMachineNode(W65816::LDAindirectIdx, DL, VTs, Ops);

          CurDAG->setNodeMemRefs(Load, {LD->getMemOperand()});
          ReplaceNode(N, Load);
          return;
        }
      }

      // Check for DP indirect: (load (load (wrapper GA_dp)))
      // This is dereferencing a pointer stored in direct page.
      // We can use LDA ($dp) instead of stack-relative indirect.
      if (Addr.getOpcode() == ISD::LOAD) {
        LoadSDNode *PtrLoad = cast<LoadSDNode>(Addr.getNode());
        SDValue PtrAddr = PtrLoad->getBasePtr();

        // Check if the pointer is loaded from a direct page global
        if (PtrAddr.getOpcode() == W65816ISD::WRAPPER) {
          SDValue Inner = PtrAddr.getOperand(0);
          if (GlobalAddressSDNode *GA = dyn_cast<GlobalAddressSDNode>(Inner)) {
            if (isDirectPageGlobal(GA->getGlobal())) {
              // Use DP indirect: LDA ($dp)
              SDValue TargetAddr = CurDAG->getTargetGlobalAddress(
                  GA->getGlobal(), DL, MVT::i8, GA->getOffset());

              // The outer load depends on the pointer load completing
              SDValue PtrChain = PtrLoad->getChain();
              SDValue Ops[] = {TargetAddr, PtrChain};
              SDVTList VTs = CurDAG->getVTList(MVT::i16, MVT::Other);
              MachineSDNode *Load =
                  CurDAG->getMachineNode(W65816::LDA_dpInd, DL, VTs, Ops);

              CurDAG->setNodeMemRefs(Load, {LD->getMemOperand()});
              ReplaceNode(N, Load);
              return;
            }
          }
        }
      }

      // Check for simple pointer dereference: (load register)
      // This handles cases like *ptr where ptr is in a register
      // We need to use stack-relative indirect addressing:
      // 1. Store the pointer to a stack slot
      // 2. Use LDA (offset,S),Y with Y=0 to load through it
      if (!isa<FrameIndexSDNode>(Addr) &&
          Addr.getOpcode() != W65816ISD::WRAPPER &&
          Addr.getOpcode() != ISD::ADD &&
          !isa<GlobalAddressSDNode>(Addr)) {
        // The address is in a register - use stack-relative indirect

        MachineFunction &MF = CurDAG->getMachineFunction();
        MachineFrameInfo &MFI = MF.getFrameInfo();

        // Create a stack slot to hold the pointer (2 bytes, aligned to 2)
        int FI = MFI.CreateStackObject(2, Align(2), false);
        SDValue StackSlot = CurDAG->getTargetFrameIndex(FI, MVT::i16);

        // Store the pointer to the stack slot
        // STA_sr expects: (ins ACC16:$src, imm8:$imm)
        // We need to get the pointer into A first, then store
        // Since we're in DAG selection, we emit nodes that will be
        // converted to machine instructions

        // For simplicity, we'll use a pseudo instruction that handles
        // the entire sequence. But first, let's try the direct approach:
        // Emit: copy ptr to A (if not already), STA to stack, LDY #0, LDA (fi,S),Y

        // Actually, the cleanest approach is to use a pseudo instruction
        // that we expand later. Let's use LDAindirect with frame index.
        SDValue ZeroIdx = CurDAG->getTargetConstant(0, DL, MVT::i16);

        // Emit LDAindirect pseudo: (dst, ptr_offset, idx)
        // ptr_offset is the frame index, idx is 0 for simple dereference
        // The expansion will: store Addr to stack[FI], LDY #0, LDA (FI,S),Y
        SDValue Ops[] = {StackSlot, Addr, ZeroIdx, Chain};
        SDVTList VTs = CurDAG->getVTList(MVT::i16, MVT::Other);
        MachineSDNode *Load =
            CurDAG->getMachineNode(W65816::LDAindirect, DL, VTs, Ops);

        CurDAG->setNodeMemRefs(Load, {LD->getMemOperand()});
        ReplaceNode(N, Load);
        return;
      }
    }

    // Handle 8-bit loads with extension (zextloadi8, sextloadi8, extloadi8)
    // These need mode switching: SEP #$20, load, REP #$20, AND #$FF
    if (LD->getMemoryVT() == MVT::i8 &&
        LD->getExtensionType() != ISD::NON_EXTLOAD) {

      // Check for indexed GLOBAL access: (load i8, (add (wrapper GA), index))
      // This handles global_array[i] for byte arrays
      if (Addr.getOpcode() == ISD::ADD) {
        SDValue LHS = Addr.getOperand(0);
        SDValue RHS = Addr.getOperand(1);

        // Check for (add (wrapper GA), index) pattern
        SDValue Base;
        SDValue Index;
        if (LHS.getOpcode() == W65816ISD::WRAPPER) {
          Base = LHS.getOperand(0);
          Index = RHS;
        } else if (RHS.getOpcode() == W65816ISD::WRAPPER) {
          Base = RHS.getOperand(0);
          Index = LHS;
        }

        if (Base.getNode() && Index.getNode()) {
          if (GlobalAddressSDNode *GA = dyn_cast<GlobalAddressSDNode>(Base)) {
            // Check if index is a constant - can fold into address
            if (ConstantSDNode *CI = dyn_cast<ConstantSDNode>(Index)) {
              int64_t Offset = GA->getOffset() + CI->getSExtValue();
              // Use LDA8_abs with folded offset
              SDValue TargetAddr = CurDAG->getTargetGlobalAddress(
                  GA->getGlobal(), DL, MVT::i16, Offset);
              SDValue Ops[] = {TargetAddr, Chain};
              SDVTList VTs = CurDAG->getVTList(MVT::i16, MVT::Other);
              MachineSDNode *Load =
                  CurDAG->getMachineNode(W65816::LDA8_abs, DL, VTs, Ops);
              CurDAG->setNodeMemRefs(Load, {LD->getMemOperand()});
              ReplaceNode(N, Load);
              return;
            }

            // Variable index - use LDA8indexedX pseudo
            SDValue TargetAddr = CurDAG->getTargetGlobalAddress(
                GA->getGlobal(), DL, MVT::i16, GA->getOffset());
            SDValue Ops[] = {TargetAddr, Index, Chain};
            SDVTList VTs = CurDAG->getVTList(MVT::i16, MVT::Other);
            MachineSDNode *Load =
                CurDAG->getMachineNode(W65816::LDA8indexedX, DL, VTs, Ops);
            CurDAG->setNodeMemRefs(Load, {LD->getMemOperand()});
            ReplaceNode(N, Load);
            return;
          }
        }
      }

      // Check for indexed pointer access: (load i8, (add ptr, offset))
      // This handles ptr[i] for byte arrays where ptr is in a register
      if (Addr.getOpcode() == ISD::ADD) {
        SDValue LHS = Addr.getOperand(0);
        SDValue RHS = Addr.getOperand(1);

        // Check if this is (add ptr, offset) where neither is a global
        bool LHSIsWrapper = (LHS.getOpcode() == W65816ISD::WRAPPER);
        bool RHSIsWrapper = (RHS.getOpcode() == W65816ISD::WRAPPER);

        if (!LHSIsWrapper && !RHSIsWrapper) {
          // This is indexed pointer access for byte array: ptr[i]
          // LHS is the base pointer, RHS is the byte offset
          MachineFunction &MF = CurDAG->getMachineFunction();
          MachineFrameInfo &MFI = MF.getFrameInfo();

          int FI = MFI.CreateStackObject(2, Align(2), false);
          SDValue StackSlot = CurDAG->getTargetFrameIndex(FI, MVT::i16);

          // Use LDA8indirectIdx pseudo
          SDValue Ops[] = {StackSlot, LHS, RHS, Chain};
          SDVTList VTs = CurDAG->getVTList(MVT::i16, MVT::Other);
          MachineSDNode *Load =
              CurDAG->getMachineNode(W65816::LDA8indirectIdx, DL, VTs, Ops);

          CurDAG->setNodeMemRefs(Load, {LD->getMemOperand()});
          ReplaceNode(N, Load);
          return;
        }
      }

      // Check for constant (immediate) address: load from inttoptr (i16 N to ptr)
      // This handles volatile hardware register access like *(volatile u8*)0x420C
      if (ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Addr)) {
        // Use LDA8_abs with the constant address
        SDValue TargetAddr = CurDAG->getTargetConstant(CN->getZExtValue(), DL, MVT::i16);
        SDValue Ops[] = {TargetAddr, Chain};
        SDVTList VTs = CurDAG->getVTList(MVT::i16, MVT::Other);
        MachineSDNode *Load =
            CurDAG->getMachineNode(W65816::LDA8_abs, DL, VTs, Ops);
        CurDAG->setNodeMemRefs(Load, {LD->getMemOperand()});
        ReplaceNode(N, Load);
        return;
      }

      // Check for simple pointer dereference through register
      // This handles cases like *(u8*)ptr where ptr is in a register
      if (!isa<FrameIndexSDNode>(Addr) &&
          Addr.getOpcode() != W65816ISD::WRAPPER &&
          Addr.getOpcode() != ISD::ADD &&
          !isa<GlobalAddressSDNode>(Addr) &&
          !isa<ConstantSDNode>(Addr)) {

        // The address is in a register - use stack-relative indirect with mode switch
        MachineFunction &MF = CurDAG->getMachineFunction();
        MachineFrameInfo &MFI = MF.getFrameInfo();

        // Create a stack slot to hold the pointer (2 bytes, aligned to 2)
        int FI = MFI.CreateStackObject(2, Align(2), false);
        SDValue StackSlot = CurDAG->getTargetFrameIndex(FI, MVT::i16);

        // Use LDA8indirect pseudo which will:
        // 1. Store Addr to stack slot
        // 2. SEP #$20
        // 3. LDY #0
        // 4. LDA (FI,S),Y
        // 5. REP #$20
        // 6. AND #$FF
        SDValue ZeroIdx = CurDAG->getTargetConstant(0, DL, MVT::i16);

        SDValue Ops[] = {StackSlot, Addr, ZeroIdx, Chain};
        SDVTList VTs = CurDAG->getVTList(MVT::i16, MVT::Other);
        MachineSDNode *Load =
            CurDAG->getMachineNode(W65816::LDA8indirect, DL, VTs, Ops);

        CurDAG->setNodeMemRefs(Load, {LD->getMemOperand()});
        ReplaceNode(N, Load);
        return;
      }
    }
    break;
  }

  case ISD::AND:
  case ISD::OR:
  case ISD::XOR:
  case ISD::ADD:
  case ISD::SUB: {
    // Optimize (binop (zextload i8), (zextload i8)) pattern
    // When both operands are 8-bit loads being zero-extended to 16-bit,
    // we can do the operation in 8-bit mode and only need one register.
    // This avoids register pressure issues since the W65816 only has A, X, Y.
    //
    // Instead of:
    //   lda addr1 ; zext ; spill ; lda addr2 ; zext ; reload ; binop16rr
    // We generate:
    //   sep #32 ; lda addr1 ; binop addr2 ; rep #32 ; and #255

    SDValue LHS = N->getOperand(0);
    SDValue RHS = N->getOperand(1);

    // Check if both operands are zextload from i8
    LoadSDNode *LHSLoad = nullptr;
    LoadSDNode *RHSLoad = nullptr;

    if (auto *LD = dyn_cast<LoadSDNode>(LHS)) {
      if (LD->getMemoryVT() == MVT::i8 &&
          LD->getExtensionType() != ISD::NON_EXTLOAD) {
        LHSLoad = LD;
      }
    }

    if (auto *LD = dyn_cast<LoadSDNode>(RHS)) {
      if (LD->getMemoryVT() == MVT::i8 &&
          LD->getExtensionType() != ISD::NON_EXTLOAD) {
        RHSLoad = LD;
      }
    }

    // Only handle if both operands are 8-bit extending loads with single use
    // If loads have multiple uses, we can't bypass them - fall through to default
    // Also check that the load chain outputs have no users - if they do, bypassing
    // the loads would leave dangling chain references causing scheduling issues.
    if (LHSLoad && RHSLoad &&
        LHS.hasOneUse() && RHS.hasOneUse() &&
        !LHSLoad->hasAnyUseOfValue(1) && !RHSLoad->hasAnyUseOfValue(1)) {
      SDValue LHSAddr = LHSLoad->getBasePtr();
      SDValue RHSAddr = RHSLoad->getBasePtr();

      // Check if both addresses are simple global addresses (WRAPPER nodes)
      // This is the common case for boolean/byte variables
      if (LHSAddr.getOpcode() == W65816ISD::WRAPPER &&
          RHSAddr.getOpcode() == W65816ISD::WRAPPER) {

        SDValue LHSInner = LHSAddr.getOperand(0);
        SDValue RHSInner = RHSAddr.getOperand(0);

        GlobalAddressSDNode *LHSGA = dyn_cast<GlobalAddressSDNode>(LHSInner);
        GlobalAddressSDNode *RHSGA = dyn_cast<GlobalAddressSDNode>(RHSInner);

        if (LHSGA && RHSGA) {
          // Both are global addresses - we can use memory-operand form
          // Generate: LDA8_abs addr1, then binop8_abs addr2

          // Determine which pseudo instruction to use for the binop
          unsigned BinopOpc;
          switch (Opcode) {
          case ISD::AND: BinopOpc = W65816::AND8_abs; break;
          case ISD::OR:  BinopOpc = W65816::ORA8_abs; break;
          case ISD::XOR: BinopOpc = W65816::EOR8_abs; break;
          case ISD::ADD: BinopOpc = W65816::ADC8_abs; break;
          case ISD::SUB: BinopOpc = W65816::SBC8_abs; break;
          default: llvm_unreachable("Unexpected opcode");
          }

          // First load LHS with LDA8_abs
          SDValue LHSTargetAddr = CurDAG->getTargetGlobalAddress(
              LHSGA->getGlobal(), DL, MVT::i16, LHSGA->getOffset());
          SDValue LHSChain = LHSLoad->getChain();
          SDValue LHSOps[] = {LHSTargetAddr, LHSChain};
          SDVTList LoadVTs = CurDAG->getVTList(MVT::i16, MVT::Other);
          MachineSDNode *LoadNode =
              CurDAG->getMachineNode(W65816::LDA8_abs, DL, LoadVTs, LHSOps);
          CurDAG->setNodeMemRefs(LoadNode, {LHSLoad->getMemOperand()});

          // Then do the binop with RHS using memory operand form
          SDValue RHSTargetAddr = CurDAG->getTargetGlobalAddress(
              RHSGA->getGlobal(), DL, MVT::i16, RHSGA->getOffset());
          // Chain the binop after the load
          SDValue BinopChain = SDValue(LoadNode, 1);
          // The binop takes: A (implicit from load), addr, chain
          // Result is in A (i16, zero-extended)
          SDValue BinopOps[] = {SDValue(LoadNode, 0), RHSTargetAddr, BinopChain};
          SDVTList BinopVTs = CurDAG->getVTList(MVT::i16, MVT::Other);
          MachineSDNode *BinopNode =
              CurDAG->getMachineNode(BinopOpc, DL, BinopVTs, BinopOps);
          CurDAG->setNodeMemRefs(BinopNode, {RHSLoad->getMemOperand()});

          ReplaceNode(N, BinopNode);
          return;
        }
      }
    }
    break;
  }

  // Note: W65816ISD::CALL and W65816ISD::FAR_CALL are handled by TableGen patterns
  // The SDNPVariadic flag ensures that argument register operands become implicit uses
  }

  // Select the default instruction
  SelectCode(N);
}

bool W65816DAGToDAGISel::SelectAddr(SDValue Addr, SDValue &Base) {
  SDLoc DL(Addr);

  // Handle frame indices
  if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(Addr)) {
    Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i16);
    return true;
  }

  // Handle direct target addresses
  if (Addr.getOpcode() == ISD::TargetGlobalAddress ||
      Addr.getOpcode() == ISD::TargetExternalSymbol) {
    Base = Addr;
    return true;
  }

  // Handle WRAPPER nodes (global addresses)
  if (Addr.getOpcode() == W65816ISD::WRAPPER) {
    Base = Addr.getOperand(0);
    return true;
  }

  // Handle (add (WRAPPER TargetGA), const) - fold offset into address
  if (Addr.getOpcode() == ISD::ADD) {
    SDValue LHS = Addr.getOperand(0);
    SDValue RHS = Addr.getOperand(1);

    // Check for (add (WRAPPER TargetGA), const)
    if (LHS.getOpcode() == W65816ISD::WRAPPER && isa<ConstantSDNode>(RHS)) {
      SDValue Inner = LHS.getOperand(0);
      int64_t Offset = cast<ConstantSDNode>(RHS)->getSExtValue();

      if (GlobalAddressSDNode *GA = dyn_cast<GlobalAddressSDNode>(Inner)) {
        // Create a new TargetGlobalAddress with the combined offset
        Base = CurDAG->getTargetGlobalAddress(GA->getGlobal(), DL, MVT::i16,
                                               GA->getOffset() + Offset);
        return true;
      }
    }

    // Check for (add const, (WRAPPER TargetGA)) - commuted form
    if (RHS.getOpcode() == W65816ISD::WRAPPER && isa<ConstantSDNode>(LHS)) {
      SDValue Inner = RHS.getOperand(0);
      int64_t Offset = cast<ConstantSDNode>(LHS)->getSExtValue();

      if (GlobalAddressSDNode *GA = dyn_cast<GlobalAddressSDNode>(Inner)) {
        Base = CurDAG->getTargetGlobalAddress(GA->getGlobal(), DL, MVT::i16,
                                               GA->getOffset() + Offset);
        return true;
      }
    }
  }

  // Don't match arbitrary values (like registers) as addresses.
  // The W65816 can only directly address memory via:
  // - Frame indices (stack-relative)
  // - Global addresses (absolute)
  // - Direct page addresses
  // For pointer dereference (register as address), we need indirect addressing
  // which is handled specially in Select().
  return false;
}

FunctionPass *llvm::createW65816ISelDag(W65816TargetMachine &TM,
                                        CodeGenOptLevel OptLevel) {
  return new W65816DAGToDAGISelLegacy(TM, OptLevel);
}
