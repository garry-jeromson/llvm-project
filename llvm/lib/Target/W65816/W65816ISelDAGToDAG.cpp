//===-- W65816ISelDAGToDAG.cpp - A DAG to DAG Inst Selector for W65816 ----===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file defines an instruction selector for the W65816 target.
//
//===----------------------------------------------------------------------===//

#include "W65816.h"
#include "W65816ISelLowering.h"
#include "W65816Subtarget.h"
#include "W65816TargetMachine.h"
#include "MCTargetDesc/W65816MCTargetDesc.h"

#include "llvm/CodeGen/MachineFrameInfo.h"
#include "llvm/CodeGen/MachineFunction.h"
#include "llvm/CodeGen/MachineRegisterInfo.h"
#include "llvm/CodeGen/SelectionDAG.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/CodeGen/SelectionDAGNodes.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/GlobalVariable.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/raw_ostream.h"

#define DEBUG_TYPE "w65816-isel"
#define PASS_NAME "W65816 DAG->DAG Instruction Selection"

using namespace llvm;

namespace {

/// Check if a global variable is in the zero/direct page section.
/// The W65816 direct page allows 8-bit addressing for the first 256 bytes.
/// Globals marked with section ".zeropage" or ".directpage" can use
/// the faster 2-byte direct page instructions.
static bool isDirectPageGlobal(const GlobalValue *GV) {
  if (!GV)
    return false;

  StringRef Section = GV->getSection();
  if (Section.empty())
    return false;

  // Check for common zero page section names
  return Section == ".zeropage" || Section == ".directpage" ||
         Section == ".zp" || Section == "zeropage" || Section == "directpage";
}

class W65816DAGToDAGISel : public SelectionDAGISel {
public:
  W65816DAGToDAGISel() = delete;

  explicit W65816DAGToDAGISel(W65816TargetMachine &TM, CodeGenOptLevel OptLevel)
      : SelectionDAGISel(TM, OptLevel) {}

  bool runOnMachineFunction(MachineFunction &MF) override {
    Subtarget = &MF.getSubtarget<W65816Subtarget>();
    return SelectionDAGISel::runOnMachineFunction(MF);
  }

  void Select(SDNode *N) override;

  bool SelectAddr(SDValue Addr, SDValue &Base);

  StringRef getPassName() const { return PASS_NAME; }

// Include the pieces autogenerated from the target description
#include "W65816GenDAGISel.inc"

private:
  const W65816Subtarget *Subtarget = nullptr;
};

class W65816DAGToDAGISelLegacy : public SelectionDAGISelLegacy {
public:
  static char ID;

  explicit W65816DAGToDAGISelLegacy(W65816TargetMachine &TM,
                                    CodeGenOptLevel OptLevel)
      : SelectionDAGISelLegacy(
            ID, std::make_unique<W65816DAGToDAGISel>(TM, OptLevel)) {}
};

char W65816DAGToDAGISelLegacy::ID = 0;

} // end anonymous namespace

INITIALIZE_PASS(W65816DAGToDAGISelLegacy, DEBUG_TYPE, PASS_NAME, false, false)

void W65816DAGToDAGISel::Select(SDNode *N) {
  // If we have a custom node, we have already selected
  if (N->isMachineOpcode()) {
    LLVM_DEBUG(dbgs() << "== "; N->dump(CurDAG); dbgs() << "\n");
    N->setNodeId(-1);
    return;
  }

  unsigned Opcode = N->getOpcode();
  SDLoc DL(N);

  switch (Opcode) {
  default:
    break;

  case ISD::CopyToReg: {
    // Handle CopyToReg with immediate source to X or Y register
    // This needs special handling because we need to use LDX/LDY instructions
    SDValue Chain = N->getOperand(0);
    SDValue DestReg = N->getOperand(1);
    SDValue Src = N->getOperand(2);
    bool HasGlueIn = N->getNumOperands() > 3;
    bool HasGlueOut = N->getNumValues() > 1;

    // Check if destination is a physical register
    if (RegisterSDNode *RN = dyn_cast<RegisterSDNode>(DestReg)) {
      Register Reg = RN->getReg();

      // Check if source is an immediate
      if (ConstantSDNode *Imm = dyn_cast<ConstantSDNode>(Src)) {
        int64_t Val = Imm->getSExtValue();
        unsigned LoadOpc = 0;

        if (Reg == W65816::X) {
          LoadOpc = W65816::LDX_imm16;
        } else if (Reg == W65816::Y) {
          LoadOpc = W65816::LDY_imm16;
        }

        if (LoadOpc != 0) {
          // Create the load immediate instruction
          SDValue ImmVal = CurDAG->getTargetConstant(Val, DL, MVT::i16);

          // Build operands - the instruction just takes the immediate
          SmallVector<SDValue, 4> Ops;
          Ops.push_back(ImmVal);

          // Add chain as implicit operand
          Ops.push_back(Chain);

          // Add glue input if present
          if (HasGlueIn)
            Ops.push_back(N->getOperand(3));

          // Output types: the register value, chain, and optionally glue
          SmallVector<EVT, 3> VTs;
          VTs.push_back(MVT::i16);  // The loaded value (implicit def of reg)
          VTs.push_back(MVT::Other);  // Chain
          if (HasGlueOut)
            VTs.push_back(MVT::Glue);

          MachineSDNode *LoadInst = CurDAG->getMachineNode(
              LoadOpc, DL, CurDAG->getVTList(VTs), Ops);

          // Replace uses:
          // - Output 0 (value) isn't directly used since it's going to phys reg
          // - Output 1 (chain) replaces the original chain output
          // - Output 2 (glue) replaces original glue output if present
          ReplaceUses(SDValue(N, 0), SDValue(LoadInst, 1));  // chain
          if (HasGlueOut)
            ReplaceUses(SDValue(N, 1), SDValue(LoadInst, 2));  // glue

          CurDAG->RemoveDeadNode(N);
          return;
        }
        // For A register, fall through to default handling (LDA_imm16 pattern)
      }
    }
    break;
  }

  case ISD::FrameIndex: {
    int FI = cast<FrameIndexSDNode>(N)->getIndex();
    SDValue TFI = CurDAG->getTargetFrameIndex(FI, MVT::i16);
    ReplaceNode(N, TFI.getNode());
    return;
  }

  case W65816ISD::WRAPPER: {
    // WRAPPER just contains the target address - select it as-is
    // The inner TargetGlobalAddress will be used directly
    SDValue Addr = N->getOperand(0);
    // For WRAPPER nodes used as addresses, we let the pattern matching
    // handle them via SelectAddr. If WRAPPER is used standalone,
    // we need to materialize the address.
    // For now, just replace with the inner address
    ReplaceNode(N, Addr.getNode());
    return;
  }

  case ISD::STORE: {
    // Check if storing to a frame index - use stack-relative addressing
    StoreSDNode *ST = cast<StoreSDNode>(N);
    SDValue Chain = ST->getChain();
    SDValue Value = ST->getValue();
    SDValue Addr = ST->getBasePtr();

    // Only handle simple stores of i16
    if (ST->getMemoryVT() == MVT::i16 && !ST->isTruncatingStore()) {
      // TODO: Memory shift optimization (ASL/LSR $addr instead of load-shift-store)
      // Disabled for now - needs more work on chain handling.
      // The memory shift instructions are defined and can be used via intrinsics.

      // Check for frame index - use stack-relative addressing
      if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(Addr)) {
        int FI = FIN->getIndex();
        SDValue TFI = CurDAG->getTargetFrameIndex(FI, MVT::i16);

        // Emit STA_sr: store A to stack-relative address
        SDValue Ops[] = {Value, TFI, Chain};
        MachineSDNode *Store =
            CurDAG->getMachineNode(W65816::STA_sr, DL, MVT::Other, Ops);

        CurDAG->setNodeMemRefs(Store, {ST->getMemOperand()});
        ReplaceNode(N, Store);
        return;
      }

      // Check for direct page addressing: (store val, (wrapper GA))
      // where GA is in a zero page section
      if (Addr.getOpcode() == W65816ISD::WRAPPER) {
        SDValue Inner = Addr.getOperand(0);
        if (GlobalAddressSDNode *GA = dyn_cast<GlobalAddressSDNode>(Inner)) {
          if (isDirectPageGlobal(GA->getGlobal())) {
            // Use direct page store (2-byte instruction)
            // The address is 8-bit, so we create a target global with i8 type
            SDValue TargetAddr = CurDAG->getTargetGlobalAddress(
                GA->getGlobal(), DL, MVT::i8, GA->getOffset());

            SDValue Ops[] = {Value, TargetAddr, Chain};
            MachineSDNode *Store =
                CurDAG->getMachineNode(W65816::STA_dp, DL, MVT::Other, Ops);

            CurDAG->setNodeMemRefs(Store, {ST->getMemOperand()});
            ReplaceNode(N, Store);
            return;
          }
        }
      }

      // Check for indexed addressing: (store val, (add (wrapper GA), index))
      if (Addr.getOpcode() == ISD::ADD) {
        SDValue LHS = Addr.getOperand(0);
        SDValue RHS = Addr.getOperand(1);

        // Check for (add (wrapper GA), index) pattern
        SDValue Base;
        SDValue Index;
        if (LHS.getOpcode() == W65816ISD::WRAPPER) {
          Base = LHS.getOperand(0);
          Index = RHS;
        } else if (RHS.getOpcode() == W65816ISD::WRAPPER) {
          Base = RHS.getOperand(0);
          Index = LHS;
        }

        if (Base.getNode() && Index.getNode()) {
          // We have a (wrapper GA) + index pattern
          // Use STAindexedX pseudo instruction which handles register
          // allocation conflicts properly. The pseudo is expanded after
          // register allocation when we know the physical registers.
          if (GlobalAddressSDNode *GA = dyn_cast<GlobalAddressSDNode>(Base)) {
            // For now, always use absolute indexed (not direct page)
            // Direct page indexed would need a separate pseudo
            SDValue TargetAddr = CurDAG->getTargetGlobalAddress(
                GA->getGlobal(), DL, MVT::i16, GA->getOffset());

            // Emit STAindexedX pseudo: (val, addr, idx)
            // This pseudo will be expanded after register allocation
            // to properly handle register conflicts
            SDValue Ops[] = {Value, TargetAddr, Index, Chain};
            MachineSDNode *Store =
                CurDAG->getMachineNode(W65816::STAindexedX, DL, MVT::Other, Ops);

            CurDAG->setNodeMemRefs(Store, {ST->getMemOperand()});
            ReplaceNode(N, Store);
            return;
          }
        }
      }

      // Check for indexed pointer store: (store val, (add ptr, offset))
      // where ptr is a register and offset is computed
      if (Addr.getOpcode() == ISD::ADD) {
        SDValue LHS = Addr.getOperand(0);
        SDValue RHS = Addr.getOperand(1);

        // Check if this is (add ptr, byte_offset) where neither is a global
        bool LHSIsWrapper = (LHS.getOpcode() == W65816ISD::WRAPPER);
        bool RHSIsWrapper = (RHS.getOpcode() == W65816ISD::WRAPPER);

        if (!LHSIsWrapper && !RHSIsWrapper) {
          // This is indexed pointer store: ptr[i] = val
          MachineFunction &MF = CurDAG->getMachineFunction();
          MachineFrameInfo &MFI = MF.getFrameInfo();

          int FI = MFI.CreateStackObject(2, Align(2), false);
          SDValue StackSlot = CurDAG->getTargetFrameIndex(FI, MVT::i16);

          // Use STAindirectIdx pseudo
          SDValue Ops[] = {Value, StackSlot, LHS, RHS, Chain};
          MachineSDNode *Store =
              CurDAG->getMachineNode(W65816::STAindirectIdx, DL, MVT::Other, Ops);

          CurDAG->setNodeMemRefs(Store, {ST->getMemOperand()});
          ReplaceNode(N, Store);
          return;
        }
      }

      // Check for store through a pointer in a register (e.g., *ptr = val)
      // If Addr is not a frame index, wrapper, or add pattern, it's a register
      // We need to use stack-relative indirect addressing:
      // 1. Store the pointer to a stack slot
      // 2. Use STA (offset,S),Y with Y=0 to store through it
      if (!isa<FrameIndexSDNode>(Addr) &&
          Addr.getOpcode() != W65816ISD::WRAPPER &&
          Addr.getOpcode() != ISD::ADD) {
        // The address is in a register - use stack-relative indirect
        MachineFunction &MF = CurDAG->getMachineFunction();
        MachineFrameInfo &MFI = MF.getFrameInfo();

        // Create a stack slot to hold the pointer (2 bytes, aligned to 2)
        int FI = MFI.CreateStackObject(2, Align(2), false);
        SDValue StackSlot = CurDAG->getTargetFrameIndex(FI, MVT::i16);

        // Use STAindirect pseudo which will be expanded after register allocation
        SDValue ZeroIdx = CurDAG->getTargetConstant(0, DL, MVT::i16);
        SDValue Ops[] = {Value, StackSlot, Addr, ZeroIdx, Chain};
        MachineSDNode *Store =
            CurDAG->getMachineNode(W65816::STAindirect, DL, MVT::Other, Ops);

        CurDAG->setNodeMemRefs(Store, {ST->getMemOperand()});
        ReplaceNode(N, Store);
        return;
      }
    }
    break;
  }

  case ISD::LOAD: {
    // Check if loading from a frame index - use stack-relative addressing
    LoadSDNode *LD = cast<LoadSDNode>(N);
    SDValue Chain = LD->getChain();
    SDValue Addr = LD->getBasePtr();

    // Only handle simple loads of i16
    if (LD->getMemoryVT() == MVT::i16 && LD->getExtensionType() == ISD::NON_EXTLOAD) {
      // Check for frame index - use stack-relative addressing
      if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(Addr)) {
        int FI = FIN->getIndex();
        SDValue TFI = CurDAG->getTargetFrameIndex(FI, MVT::i16);

        // Emit LDA_sr: load A from stack-relative address
        SDValue Ops[] = {TFI, Chain};
        SDVTList VTs = CurDAG->getVTList(MVT::i16, MVT::Other);
        MachineSDNode *Load =
            CurDAG->getMachineNode(W65816::LDA_sr, DL, VTs, Ops);

        CurDAG->setNodeMemRefs(Load, {LD->getMemOperand()});
        ReplaceNode(N, Load);
        return;
      }

      // Check for direct page addressing: (load (wrapper GA))
      // where GA is in a zero page section
      if (Addr.getOpcode() == W65816ISD::WRAPPER) {
        SDValue Inner = Addr.getOperand(0);
        if (GlobalAddressSDNode *GA = dyn_cast<GlobalAddressSDNode>(Inner)) {
          if (isDirectPageGlobal(GA->getGlobal())) {
            // Use direct page load (2-byte instruction)
            SDValue TargetAddr = CurDAG->getTargetGlobalAddress(
                GA->getGlobal(), DL, MVT::i8, GA->getOffset());

            SDValue Ops[] = {TargetAddr, Chain};
            SDVTList VTs = CurDAG->getVTList(MVT::i16, MVT::Other);
            MachineSDNode *Load =
                CurDAG->getMachineNode(W65816::LDA_dp, DL, VTs, Ops);

            CurDAG->setNodeMemRefs(Load, {LD->getMemOperand()});
            ReplaceNode(N, Load);
            return;
          }
        }
      }

      // Check for indexed addressing: (load (add (wrapper GA), index))
      if (Addr.getOpcode() == ISD::ADD) {
        SDValue LHS = Addr.getOperand(0);
        SDValue RHS = Addr.getOperand(1);

        // Check for (add (wrapper GA), index) pattern
        SDValue Base;
        SDValue Index;
        if (LHS.getOpcode() == W65816ISD::WRAPPER) {
          Base = LHS.getOperand(0);
          Index = RHS;
        } else if (RHS.getOpcode() == W65816ISD::WRAPPER) {
          Base = RHS.getOperand(0);
          Index = LHS;
        }

        if (Base.getNode() && Index.getNode()) {
          // We have a (wrapper GA) + index pattern
          // Use LDAindexedX pseudo instruction which handles register
          // allocation properly. The pseudo is expanded after register
          // allocation when we know the physical registers.
          if (GlobalAddressSDNode *GA = dyn_cast<GlobalAddressSDNode>(Base)) {
            // For now, always use absolute indexed (not direct page)
            // Direct page indexed would need a separate pseudo
            SDValue TargetAddr = CurDAG->getTargetGlobalAddress(
                GA->getGlobal(), DL, MVT::i16, GA->getOffset());

            // Emit LDAindexedX pseudo: (dst, addr, idx)
            // This pseudo will be expanded after register allocation
            // to properly handle register conflicts
            SDValue Ops[] = {TargetAddr, Index, Chain};
            SDVTList VTs = CurDAG->getVTList(MVT::i16, MVT::Other);
            MachineSDNode *Load =
                CurDAG->getMachineNode(W65816::LDAindexedX, DL, VTs, Ops);

            CurDAG->setNodeMemRefs(Load, {LD->getMemOperand()});
            ReplaceNode(N, Load);
            return;
          }
        }
      }

      // Check for indexed pointer access: (load (add ptr, offset))
      // where ptr is a register and offset is computed (e.g., i*2 for i16 arrays)
      // This handles ptr[i] where ptr is in a register
      if (Addr.getOpcode() == ISD::ADD) {
        SDValue LHS = Addr.getOperand(0);
        SDValue RHS = Addr.getOperand(1);

        // Check if this is (add ptr, byte_offset) where neither is a global
        // (global indexed access is handled above)
        bool LHSIsWrapper = (LHS.getOpcode() == W65816ISD::WRAPPER);
        bool RHSIsWrapper = (RHS.getOpcode() == W65816ISD::WRAPPER);

        if (!LHSIsWrapper && !RHSIsWrapper) {
          // This is indexed pointer access: ptr[i]
          // LHS is typically the base pointer, RHS is the byte offset
          // We'll use stack-relative indirect indexed addressing:
          // 1. Store base pointer to stack slot
          // 2. Load byte offset to Y
          // 3. Use LDA (offset,S),Y

          MachineFunction &MF = CurDAG->getMachineFunction();
          MachineFrameInfo &MFI = MF.getFrameInfo();

          int FI = MFI.CreateStackObject(2, Align(2), false);
          SDValue StackSlot = CurDAG->getTargetFrameIndex(FI, MVT::i16);

          // Use LDAindirectIdx pseudo: stores LHS (ptr) to stack, puts RHS (offset) in Y
          // Then uses LDA (offset,S),Y
          SDValue Ops[] = {StackSlot, LHS, RHS, Chain};
          SDVTList VTs = CurDAG->getVTList(MVT::i16, MVT::Other);
          MachineSDNode *Load =
              CurDAG->getMachineNode(W65816::LDAindirectIdx, DL, VTs, Ops);

          CurDAG->setNodeMemRefs(Load, {LD->getMemOperand()});
          ReplaceNode(N, Load);
          return;
        }
      }

      // Check for simple pointer dereference: (load register)
      // This handles cases like *ptr where ptr is in a register
      // We need to use stack-relative indirect addressing:
      // 1. Store the pointer to a stack slot
      // 2. Use LDA (offset,S),Y with Y=0 to load through it
      if (!isa<FrameIndexSDNode>(Addr) &&
          Addr.getOpcode() != W65816ISD::WRAPPER &&
          Addr.getOpcode() != ISD::ADD) {
        // The address is in a register - use stack-relative indirect

        MachineFunction &MF = CurDAG->getMachineFunction();
        MachineFrameInfo &MFI = MF.getFrameInfo();

        // Create a stack slot to hold the pointer (2 bytes, aligned to 2)
        int FI = MFI.CreateStackObject(2, Align(2), false);
        SDValue StackSlot = CurDAG->getTargetFrameIndex(FI, MVT::i16);

        // Store the pointer to the stack slot
        // STA_sr expects: (ins ACC16:$src, imm8:$imm)
        // We need to get the pointer into A first, then store
        // Since we're in DAG selection, we emit nodes that will be
        // converted to machine instructions

        // For simplicity, we'll use a pseudo instruction that handles
        // the entire sequence. But first, let's try the direct approach:
        // Emit: copy ptr to A (if not already), STA to stack, LDY #0, LDA (fi,S),Y

        // Actually, the cleanest approach is to use a pseudo instruction
        // that we expand later. Let's use LDAindirect with frame index.
        SDValue ZeroIdx = CurDAG->getTargetConstant(0, DL, MVT::i16);

        // Emit LDAindirect pseudo: (dst, ptr_offset, idx)
        // ptr_offset is the frame index, idx is 0 for simple dereference
        // The expansion will: store Addr to stack[FI], LDY #0, LDA (FI,S),Y
        SDValue Ops[] = {StackSlot, Addr, ZeroIdx, Chain};
        SDVTList VTs = CurDAG->getVTList(MVT::i16, MVT::Other);
        MachineSDNode *Load =
            CurDAG->getMachineNode(W65816::LDAindirect, DL, VTs, Ops);

        CurDAG->setNodeMemRefs(Load, {LD->getMemOperand()});
        ReplaceNode(N, Load);
        return;
      }
    }
    break;
  }

  case W65816ISD::CALL: {
    // Select W65816 call to JSR instruction
    SDValue Chain = N->getOperand(0);
    SDValue Callee = N->getOperand(1);

    // Handle different callee types
    SDValue Target;
    if (GlobalAddressSDNode *G = dyn_cast<GlobalAddressSDNode>(Callee)) {
      Target = CurDAG->getTargetGlobalAddress(G->getGlobal(), DL, MVT::i16,
                                              G->getOffset());
    } else if (ExternalSymbolSDNode *E = dyn_cast<ExternalSymbolSDNode>(Callee)) {
      Target = CurDAG->getTargetExternalSymbol(E->getSymbol(), MVT::i16);
    } else {
      // Direct address
      Target = Callee;
    }

    // Collect all operands for the JSR
    SmallVector<SDValue, 8> Ops;
    Ops.push_back(Target);
    Ops.push_back(Chain);

    // Add any glue input
    if (N->getGluedNode())
      Ops.push_back(N->getOperand(N->getNumOperands() - 1));

    // Create the JSR node
    SDVTList VTs = CurDAG->getVTList(MVT::Other, MVT::Glue);
    MachineSDNode *Call = CurDAG->getMachineNode(W65816::JSR, DL, VTs, Ops);

    ReplaceNode(N, Call);
    return;
  }
  }

  // Select the default instruction
  SelectCode(N);
}

bool W65816DAGToDAGISel::SelectAddr(SDValue Addr, SDValue &Base) {
  SDLoc DL(Addr);

  // Handle frame indices
  if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(Addr)) {
    Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i16);
    return true;
  }

  // Handle direct target addresses
  if (Addr.getOpcode() == ISD::TargetGlobalAddress ||
      Addr.getOpcode() == ISD::TargetExternalSymbol) {
    Base = Addr;
    return true;
  }

  // Handle WRAPPER nodes (global addresses)
  if (Addr.getOpcode() == W65816ISD::WRAPPER) {
    Base = Addr.getOperand(0);
    return true;
  }

  // Handle (add (WRAPPER TargetGA), const) - fold offset into address
  if (Addr.getOpcode() == ISD::ADD) {
    SDValue LHS = Addr.getOperand(0);
    SDValue RHS = Addr.getOperand(1);

    // Check for (add (WRAPPER TargetGA), const)
    if (LHS.getOpcode() == W65816ISD::WRAPPER && isa<ConstantSDNode>(RHS)) {
      SDValue Inner = LHS.getOperand(0);
      int64_t Offset = cast<ConstantSDNode>(RHS)->getSExtValue();

      if (GlobalAddressSDNode *GA = dyn_cast<GlobalAddressSDNode>(Inner)) {
        // Create a new TargetGlobalAddress with the combined offset
        Base = CurDAG->getTargetGlobalAddress(GA->getGlobal(), DL, MVT::i16,
                                               GA->getOffset() + Offset);
        return true;
      }
    }

    // Check for (add const, (WRAPPER TargetGA)) - commuted form
    if (RHS.getOpcode() == W65816ISD::WRAPPER && isa<ConstantSDNode>(LHS)) {
      SDValue Inner = RHS.getOperand(0);
      int64_t Offset = cast<ConstantSDNode>(LHS)->getSExtValue();

      if (GlobalAddressSDNode *GA = dyn_cast<GlobalAddressSDNode>(Inner)) {
        Base = CurDAG->getTargetGlobalAddress(GA->getGlobal(), DL, MVT::i16,
                                               GA->getOffset() + Offset);
        return true;
      }
    }
  }

  // Don't match arbitrary values (like registers) as addresses.
  // The W65816 can only directly address memory via:
  // - Frame indices (stack-relative)
  // - Global addresses (absolute)
  // - Direct page addresses
  // For pointer dereference (register as address), we need indirect addressing
  // which is handled specially in Select().
  return false;
}

FunctionPass *llvm::createW65816ISelDag(W65816TargetMachine &TM,
                                        CodeGenOptLevel OptLevel) {
  return new W65816DAGToDAGISelLegacy(TM, OptLevel);
}
